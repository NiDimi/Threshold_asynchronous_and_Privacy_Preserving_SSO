from hashlib import sha256

from bplib.bp import BpGroup
from petlib.bn import Bn


def setup():
    """
    Generate the Public Parameters (PP)

    :return
        - params: the PP
    """
    G = BpGroup()
    g1, g2 = G.gen1(), G.gen2()
    e, o = G.pair, G.order()
    return G, o, g1, g2, e


def keygen(params):
    """
    Generates the private and public keys

    :param params: the PP generated by setup()
    :return: the keys
    """
    G, o, g1, g2, e = params
    x, y = o.random(), o.random()
    sk = (x, y)
    pk = (g2, x * g2, y * g2)
    return sk, pk


def provide_id(request, data, sk, params):
    if not verifY_request(request, data):
        return 0
    return sign_cred(request, sk, params)


def verifY_request(request, data):
    # Basically Schnorr NIZKP
    # V -> A*c + g*r0
    # True if hash(A || V || data) =c
    return True


def sign_cred(user_commitment, sk, params):
    """
    Applying the signing on the blinded user credentials
    by applying the PS signature scheme

    :param params: the PP
    :param user_commitment: The commitment that the user sent
    :param sk: the secret key
    :return: the PS signature (sig1, sig2)
    """
    G, o, g1, g2, e = params
    x, y = sk
    h = o.random() * g1
    sig = (h, h * (x + y * user_commitment))
    return sig


# m = Bn.from_binary(sha256(b"Hello World!").digest())
# params = setup()
# sk, pk = keygen(params)
# print(provide_id(m,True, sk, params))

