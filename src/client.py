from hashlib import sha256
from petlib.bn import Bn

import helper
from helper import BpGroupHelper
from pubKey import PubKey
from request import Request
from credproof import CredProof


class Client:
    def __init__(self, idp_pk, secret):
        """
        Constructor for the client

        :param idp_pk: The public key of the IdP
        :param secret: This secret will be used to build an identity to the RP such as IdP cant use the attributes and
        the client cant create multiple users in the RP
        """
        self.__idp_pk: PubKey = idp_pk
        # Used for blinding and unblinding the signatures
        self.__t = None
        self.__secret = Bn.from_binary(sha256(secret).digest())

    def request_id(self, attributes):
        """
        Implementation of the 'Multi-Message Protocol' of the paper
        Short Randomizable Signatures the user side
        https://doi.org/10.1007/978-3-319-29485-8_7
        We only need to hide and then prove knowledge of the secret

        :param attributes: The attributes the users wants in the signature
        :return: A request object to be sent to the IdP
        """
        # Check first that the attributes is not more than the maximum attributes allowed from the IdP
        if len(attributes) > (len(self.__idp_pk.Yg1)-1):
            return 0
        C = self.__create_commitment()
        c, r, = self.__create_zkp_idp(C)
        # The idp does not need to know which attributes will be hidden
        idp_attributes = [attr[0] for attr in attributes]
        return Request(C, c, r, idp_attributes)

    def __hash_hidden_attributes(self, attributes):
        """
        Hash all the hidden attributes using SHA256

        :param attributes: The attributes to be hashed
        :return: The hashed hidden attributes
        """
        hashed_attributes = []
        for attribute in attributes:
            # Check if it is a hidden attribute
            if attribute[1]:
                hashed_attributes.append(Bn.from_binary(sha256(attribute[0]).digest()))
        return hashed_attributes

    def __create_commitment(self):
        """
        Create the commitment of the secret
        C = g1^random * Yg1 ^secret

        :return: a commitment C to the hidden attributes
        """
        o: Bn = BpGroupHelper.o
        # t is going to be the blinding factor, and we need to unblind later
        self.__t = o.random()
        return self.__idp_pk.g1 * self.__t + self.__idp_pk.Yg1[0] * self.__secret

    def __create_zkp_idp(self, C):
        """
        Creates a ZKP for the secret of the user
        V = g1 ^ random_t * Yg1[0] ^ random_s
        c = Hash(C || V)
        rt = random_t - t * c
        rs = random_s - s * c

        :param C: The commitment of the secret s
        :return: the c, r (public values) to be sent to the IdP
        """
        o: Bn = BpGroupHelper.o
        # Calculate V
        random_t, random_s = o.random(), o.random()
        V = self.__idp_pk.g1 * random_t + self.__idp_pk.Yg1[0] * random_s
        # Calculate c
        c = helper.to_challenge([C.export(), V.export()])
        # Calculate r's
        r = (random_t - self.__t * c, random_s - self.__secret * c)
        return c, r

    def unbind_sig(self, sig_prime):
        """
        Unblind the signature generated by the IdP
        sig = sig_prime1, sig_prime2 / sig_prime1 ^ randomness_used_in_sign

        :param sig_prime: The blinded signature
        :return: The un-blinded signature
        """
        sig1, sig2 = sig_prime
        return sig1, sig2 - sig1 * self.__t

    def verify_sig(self, sig, attributes):
        """
        Verify that the blinded signature provided by the IdP is correctly formed
        check if e(sig1, X_prime * Yg2[0] ^ secret * Yg2[i+1]^hash(attribute_i)) = e(sig2, g2)

        :param sig: the un-blinded signature
        :param attributes: the attributes that the signature was signed over
        :return: true if it is correct false otherwise
        """
        assert len(attributes) <= len(self.__idp_pk.Yg1)
        sig1, sig2 = sig
        verification_result = self.__idp_pk.X + self.__idp_pk.Yg2[0] * self.__secret
        for i, attribute in enumerate(attributes):
            attribute_hash = Bn.from_binary(sha256(attribute[0]).digest())
            verification_result += self.__idp_pk.Yg2[i+1] * attribute_hash
        return not sig1.isinf() and BpGroupHelper.e(sig1, verification_result) == BpGroupHelper.e(sig2,
                                                                                                  self.__idp_pk.g2)

    def prove_id(self, sig, attributes, domain):
        """
        Implementation of Section 6.2 of the paper
        Short Randomizable Signatures the prover side
        https://doi.org/10.1007/978-3-319-29485-8_7

        :param sig: The ublinded signature the user got from the IdP
        :param attributes: users attribute that he wants to prove
        :param domain: the domain of the RP
        :return: A proof object to be sent to the RP for validation
        """
        # Check first that the attributes is not more than the maximum attributes allowed from the IdP
        if len(attributes) > (len(self.__idp_pk.Yg1) - 1):
            return 0
        # We need the attributes hashed for processing (only the hidden attributes)
        hashed_attributes = self.__hash_hidden_attributes(attributes)
        random_sig = self.__randomize_signature(sig)
        # Creating user_id
        # Hash the domain to an element of G1
        domain_hash = BpGroupHelper.G.hashG1(domain)
        # The user id for the RP is the H(domain)^user_secret
        user_id = domain_hash * self.__secret
        # Calculate proof pi
        pi = self.__create_pi(hashed_attributes, attributes)
        # Construct the ZKP for the s, and the hidden attributes
        c, r = self.__create_zkp_rp(attributes, hashed_attributes, user_id, pi, domain_hash)
        # We will send to the RP the rest of the attributes in plaintext, but we add "" for placeholder of the hidden
        public_attributes = ["" if attr[1] else attr[0] for attr in attributes]
        return CredProof(random_sig, pi, user_id, c, r, public_attributes)

    def __randomize_signature(self, sig):
        """
        Randomize the signature in order to send a different one in all RPs so they cant track the user
        pick random r,t
        randomize_sig = sig1^r, (sig2 * sig1^t)^r

        :param sig: The original signature
        :return: The randomized signature
        """
        o: Bn = BpGroupHelper.o
        t = o.random()
        self.__t = t
        r = o.random()
        sig1, sig2 = sig
        return sig1 * r, (sig2 + sig1 * t) * r

    def __create_pi(self, hashed_attributes, attributes):
        """
        Create the proof pi in order to carry a zkp on. Includes only the hidden attributes
        as the public ones do not need to be hidden from the RP. Also adds the secret s and the t that was used for
        the randomizing of the signature.
        pi = Yg2[0] ^ secret * Yg2[i+1]^hash(attribute_i) * g2^t

        :param hashed_attributes: The hashed hidden attributes
        :param attributes: All the attributes (hidden + plain)
        :return: The proof pi
        """
        pi = self.__idp_pk.Yg2[0] * self.__secret + self.__idp_pk.g2 * self.__t
        j = 0
        for i, attribute in enumerate(attributes):
            if attribute[1]:
                pi += self.__idp_pk.Yg2[i+1] * hashed_attributes[j]
                j += 1
        return pi

    def __create_zkp_rp(self, attributes, hashed_attributes, user_id, pi, hashed_domain):
        """
        Creates a ZKP for the hidden attributes, the secret s, and the t used in randomizing. We need to prove to the RP
        that the secret is inside the signature, in order to not allow user to use a different random s every time.
        Hence, we will use the same randomness rs for proving the user_id of the user and that s is in the proof pi.
        Vpi = Yg2[0] ^ random_s * Yg2[i+1] ^ random_i * g2 ^random_t
        Vid = hash(domain) ^ random_s
        c = Hash(pi || user_id || Vpi || Vid)
        rt = random_t - t *c
        rs = random_s - secret *c
        ri = random_i - attribute_i * c

        :param attributes: All the attributes the user wants to send
        :param hashed_attributes: The hidden attributes hashed
        :param user_id: The user_id in th RP
        :param pi: The proof
        :param hashed_domain: The domain of the RP hashed
        :return: the c, r (public values) to be sent to the RP
        """
        o: Bn = BpGroupHelper.o
        # Calculate Vpi
        random_s, random_t = o.random(), o.random()
        Vpi = self.__idp_pk.Yg2[0] * random_s + self.__idp_pk.g2 * random_t
        randomness = []
        for i, attribute in enumerate(attributes):
            if attribute[1]:
                randomness.append(o.random())
                Vpi += self.__idp_pk.Yg2[i+1] * randomness[i]
        # Calculate Vid
        Vid = hashed_domain * random_s
        # Calculate c
        c = helper.to_challenge([pi.export(), user_id.export(), Vpi.export(), Vid.export()])
        # Calculate r's
        r = [random_t - self.__t * c, random_s - self.__secret * c]
        for i, attribute in enumerate(hashed_attributes):
            r.append(randomness[i] - attribute * c)
        return c, r
