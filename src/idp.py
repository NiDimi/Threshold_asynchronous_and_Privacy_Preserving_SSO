from hashlib import sha256
from petlib.bn import Bn

import helper
from pubKey import PubKey
from helper import BpGroupHelper
from request import Request


class IdP:
    __group = BpGroupHelper()  # The group we will be using

    def __init__(self, num_attributes):
        """
        Constructor for the IdP

        :param num_attributes: The maximum number of attributes of the user
        """
        assert num_attributes > 0
        self.__sk = None  # The secret key
        self.__pk: PubKey = None  # The public key
        self.__num_attributes = num_attributes

    def keygen(self):
        """
        Generates the private and public keys
        Pick random (x, y1,....,y_num_attributes), compute sk = g1 ^ x and
        pk =(g1,g2,g2^x, g1^y1,...,g1^y_num_attributes, g2^y1,...,g2^y_num_attributes)

        :return: the public key
        """
        o, g1, g2 = BpGroupHelper.o, BpGroupHelper.g1, BpGroupHelper.g2
        x = o.random()
        # This is the private key
        self.__sk = g1 * x
        # Generating all the public keys for each message (attribute in our case)
        pkX = g2 * x
        Yg1 = []
        Yg2 = []
        # We add plus one because we also need to add the user secret in the attributes.
        # IMPORTANT THE FIRST Yg1 and Yg2 WILL BE FOR THE USERS SECRET THE REST FOR THE ATTRIBUTES
        for i in range(self.__num_attributes + 1):
            y = o.random()
            Yg1.append(g1 * y)
            Yg2.append(g2 * y)

        self.__pk = PubKey(g1, g2, pkX, Yg1, Yg2)
        return self.__pk

    def provide_id(self, request):
        """
        Implementation of the 'Multi-Message Protocol' of the paper
        Short Randomizable Signatures the signer side (and also adding in the commitment C the attributes)
        https://doi.org/10.1007/978-3-319-29485-8_7

        :param request: The request generated by the client
        :return: the signature or zero if the ZKP verification failed
        """
        if not self.__verify_zkp(request):
            return 0
        return self.__prepare_attributes(request.C, request.attributes)

    def __verify_zkp(self, request: Request):
        """
        Verify that the client NIZKP request is correct (Basically Schnorr NIZKP verification)
        V = C^c * g1^rt * Yg1[0] ^ rs
        True if hash(C || V ) = c

        :param request: The request generated by the client
        :return: true if it is correct false otherwise
        """
        # Prepare V
        rt, rs = request.r
        V = request.C * request.c + self.__pk.g1 * rt + self.__pk.Yg1[0] * rs
        # Do the final check
        return request.c == helper.to_challenge([request.C.export(), V.export()])

    def __prepare_attributes(self, user_commitment, attributes):
        """
        Prepare the attributes for signing by adding them in the commitment C and finally sing them
        commitment += Yg1[i+1] ^ hash(public_attribute)

        :param user_commitment: The committed hidden attributes
        :param attributes: All the attributes that will go into the signature
        :return: The blinded signature
        """
        for i, attribute in enumerate(attributes):
            user_commitment += self.__pk.Yg1[i + 1] * Bn.from_binary(sha256(attribute).digest())
        return self.__sign_cred(user_commitment)

    def __sign_cred(self, commitment):
        """
        Sign the user's commitment
        blind_sig = g1^random, (sk * C)^random

        :param commitment: All the attributes committed
        :return: The PS signature
        """
        u = BpGroupHelper.o.random()
        return self.__pk.g1 * u, (self.__sk + commitment) * u
